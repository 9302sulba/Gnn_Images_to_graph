# -*- coding: utf-8 -*-
"""Gnn_Testing_on_Borah.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13aaNL2HRbequ8pjDSdrutBY5EsqmapiT
"""

# -*- coding: utf-8 -*-
"""PythonScript_Borah.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1u-am9DdBZaJt-6KxxBKMs1SCG969DF3f
"""

import cv2
import numpy as np
import igraph as ig
import matplotlib.pyplot as plt
import os
import glob

# Define the input directory
input_dir = "/bsuscratch/sulbhamalviya/Final_test_Gnn/clean_data/"
output_dir = os.path.join(input_dir,   ".." ,"Graph_Generation")

# Ensure the output directory exists
os.makedirs(output_dir, exist_ok=True)

# Define the scale function
def scale(value, m_0, M_0, m_1, M_1):
    a = (M_0 - m_0) / M_1
    b = m_0
    scaled_value = a * value + b
    return scaled_value

# Define the constants for scaling
m_0 = 0.1
M_0 = 0.46
m_1 = 0
M_1 = 255

# Process each image file
for file in glob.glob(os.path.join(input_dir, "*.jpg")):
    #print(f"Processing file: {file}")
    microstructure_image = cv2.imread(file)

    if microstructure_image is not None:
        # Convert the image to grayscale
        grayscale_image = cv2.cvtColor(microstructure_image, cv2.COLOR_BGR2GRAY)

        # Resize the grayscale image to 200x200
        resized_image = cv2.resize(grayscale_image, (224, 224))

        # Get the dimensions of the resized grayscale image
        height, width = resized_image.shape

        # Scale each pixel value
        scaled_image = np.array([scale(value, m_0, M_0, m_1, M_1) for value in resized_image.flatten()]).reshape(resized_image.shape)

        # Create an igraph graph
        rows, cols = resized_image.shape
        g = ig.Graph(directed=False)

        # Add vertices
        for i in range(rows):
            for j in range(cols):
                g.add_vertex(name=f"({i},{j})", value=scaled_image[i, j])

        # Add edges with weights and different colors (row-major, column-major, and diagonal traversals)
        edges = []
        weights = []
        colors = []

        # Row-major traversal
        for i in range(rows):
            for j in range(cols - 1):
                v1 = i * cols + j
                v2 = i * cols + (j + 1)
                weight = abs(scaled_image[i, j] - scaled_image[i, j + 1])
                edges.append((v1, v2))
                weights.append(weight)
                colors.append("blue")  # Row-major edges in blue

        # Column-major traversal
        for i in range(rows - 1):
            for j in range(cols):
                v1 = i * cols + j
                v2 = (i + 1) * cols + j
                weight = abs(scaled_image[i, j] - scaled_image[i + 1, j])
                edges.append((v1, v2))
                weights.append(weight)
                colors.append("red")  # Column-major edges in red

        # Upper right diagonal traversal
        for i in range(rows - 1):
            for j in range(cols - 1):
                v1 = i * cols + j
                v2 = (i + 1) * cols + (j + 1)
                weight = abs(scaled_image[i, j] - scaled_image[i + 1, j + 1])
                edges.append((v1, v2))
                weights.append(weight)
                colors.append("green")  # Upper right diagonal edges in green

        # Lower left diagonal traversal
        for i in range(1, rows):
            for j in range(cols - 1):
                v1 = i * cols + j
                v2 = (i - 1) * cols + (j + 1)
                weight = abs(scaled_image[i, j] - scaled_image[i - 1, j + 1])
                edges.append((v1, v2))
                weights.append(weight)
                colors.append("purple")  # Lower left diagonal edges in purple

        g.add_edges(edges)
        g.es['weight'] = weights
        g.es['color'] = colors

        # Round weights to two decimal places for labeling
        rounded_weights = [round(weight, 3) for weight in weights]
        g.es['rounded_weight'] = rounded_weights

        # Define the layout
        layout = [(j, -i) for i in range(rows) for j in range(cols)]

      # Construct the output file name
        base = os.path.basename(file)
        output_filename = f"{base.strip('.jpg')}.graphml"
        graphml_path = os.path.join(output_dir, output_filename)

      # Save the graph as GraphML
        g.write_graphml(graphml_path)

        #print(f"GraphML file for {file} saved to {graphml_path}")


        #print(f"Graph for {file} saved to {plot_path}")
    else:
        print(f"Failed to load the image {file}.")


